---
title:  spring ioc
createTime: 2017/05/15 10:23:45
permalink: /java/spring/ioc/concept/
article: false
---

# IoCとDI

## IOCコンテナ

### IOCとは

IoC（Inversion of Control、制御の反転）は、プログラムの制御フローが反転するデザイン原則です。従来のプログラミングでは、プログラマーがプログラムのフローを制御しますが、IoC では外部ソース（フレームワーク、サービス、他のコンポーネント）がそれを制御します。

Spring フレームワークでは、IoC コンテナがオブジェクトの作成、設定、管理を担当します。これにより、アプリケーションコードは依存関係の作成や管理から解放され、ビジネスロジックに集中できます。

関連する主な機能と概念：

- 依存性注入（DI）：依存関係をコンポーネントに「注入」する IoC の実装方法
- Bean：Spring IoC コンテナによって管理されるオブジェクト
- コンテナ設定：XML、アノテーション、Java コードによる Bean の定義方法
- ApplicationContext：高度な機能を提供する Spring IoC コンテナの実装
- ライフサイクル管理：Bean の作成、初期化、破棄のプロセス

#### Iocのメリット

1. **疎結合**：コンポーネントは具体的な実装ではなく抽象に依存するため、結合度が低下します
2. **テストの容易さ**：依存関係をモックや代替実装に置き換えやすくなります
3. **モジュール性**：コンポーネントは独立して開発、テスト、維持できます
4. **集中設定**：依存関係は一箇所で定義され、管理が容易になります
5. **ライフサイクル管理**：Spring がオブジェクトの作成、初期化、破棄を管理します
6. **スコープ管理**：シングルトン、プロトタイプなど、異なるスコープの Bean を管理できます
7. **保守性**：依存関係の変更が依存コンポーネントに与える影響が最小限に抑えられます

## beanとspring IOCコンテナ
![img.png](img.png)
- ① アプリbean定義　→　spring コンテナーにbean定義テーブルに登録　
- ②　bean定義テーブル -> IoCコンテナはbeanインスタンス作成
- ③ bean　インスタンス化後　IOCコンテナーにいれる　※ キャッシュプール
- ④　アプリはbeanを使用（IOCコンテナーから注入）



### Ioc 設定の三つの方法

Spring IoC コンテナを設定するには、主に 3 つの方法があります：

1. **XML ベースの設定**：
   - 従来の方法で、Bean とその依存関係を XML ファイルで定義します
   - 例：`applicationContext.xml` ファイルでの Bean 定義

```xml
<beans>
    <bean id="messageService" class="hello.spring.service.SimpleMessageService"/>
    <bean id="messageClient" class="hello.spring.client.MessageClient">
        <constructor-arg ref="messageService"/>
    </bean>
</beans>
```

2. **アノテーションベースの設定**：
   - コードにアノテーションを使用して Bean を定義します
   - 例：`@Component`, `@Service`, `@Repository`, `@Controller` などのアノテーション

```java
@Service
public class SimpleMessageService implements MessageService {
    // 実装
}

@Component
public class MessageClient {
    private final MessageService messageService;

    @Autowired
    public MessageClient(MessageService messageService) {
        this.messageService = messageService;
    }
}
```

3. **Java ベースの設定**：
   - Java クラスと `@Configuration` アノテーションを使用して Bean を定義します
   - 例：`@Configuration` クラスと `@Bean` メソッド

```java
@Configuration
public class AppConfig {
    @Bean
    public MessageService messageService() {
        return new SimpleMessageService();
    }

    @Bean
    public MessageClient messageClient(MessageService messageService) {
        return new MessageClient(messageService);
    }
}
```

### IOCとDIの関係

制御反転（Inversion of Control）は、依存性逆転原則の一種であり、コード設計のアプローチです。具体的な実装方法は依存性注入（Dependency Injection）です。
IoC は設計思想であり、DI はその実装方法です。


- **IoC（制御の反転）**：依存関係の制御をアプリケーションコードから外部（コンテナ）に移す設計原則
- **DI（依存性注入）**：IoC を実現するための具体的な手法で、依存関係をコンポーネントに注入する方法

Spring フレームワークでは、DI を通じて IoC を実装しています。DI には主に 3 つの形式があります：

1. **コンストラクタ注入**：依存関係をコンストラクタを通じて注入（推奨）
2. **セッター注入**：セッターメソッドを通じて依存関係を注入
3. **フィールド注入**：フィールドに直接依存関係を注入（`@Autowired` アノテーション）

###  IOCコンテナの種類

Spring フレームワークには、2 種類の IoC コンテナがあります：

#### BeanFactory

- Spring IoC コンテナの基本的な実装
- 軽量で、Bean の遅延初期化（Lazy Initialization）をサポート
- リソースが制限されている環境に適している
- 基本的な DI 機能のみを提供

```java
BeanFactory factory = new XmlBeanFactory(new FileSystemResource("beans.xml"));
MessageService service = (MessageService) factory.getBean("messageService");
```

#### ApplicationContext

- BeanFactory を拡張した高度な IoC コンテナ
- 追加機能：国際化（i18n）、イベント伝播、AOP 統合など
- Bean の事前初期化（Eager Initialization）がデフォルト
- エンタープライズアプリケーションに推奨

※　AOP 統合
横断的関心事（ログ記録、トランザクション管理、セキュリティなど）をビジネスロジックから分離するプログラミング手法。

```java
ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
MessageService service = context.getBean(MessageService.class);
```

主な ApplicationContext 実装：
- ClassPathXmlApplicationContext
- FileSystemXmlApplicationContext
- AnnotationConfigApplicationContext
- WebApplicationContext

##  IOCの実現

Spring IoC の実装は、以下のステップで行われます：

1. **Bean 定義の読み込み**：XML、アノテーション、Java コードから Bean 定義を読み込む
2. **Bean 定義の登録**：読み込んだ定義を BeanDefinitionRegistry に登録
3. **Bean の初期化**：Bean のインスタンス化と依存関係の注入
4. **Bean のライフサイクル管理**：初期化メソッドの呼び出し、破棄時の処理など

カスタム Bean 登録の例：

```java
@Configuration
public class CustomBeanRegistry implements BeanDefinitionRegistryPostProcessor {
    @Override
    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
        // Bean 定義の作成
        GenericBeanDefinition definition = new GenericBeanDefinition();
        definition.setBeanClass(MessageHandler.class);

        // コンストラクタ引数の設定
        ConstructorArgumentValues values = new ConstructorArgumentValues();
        values.addIndexedArgumentValue(0, "handlerName");
        values.addIndexedArgumentValue(1, new RuntimeBeanReference("accountService"));
        definition.setConstructorArgumentValues(values);

        // Bean 定義の登録
        registry.registerBeanDefinition("customMessageHandler", definition);
    }
}
```

# Beanとは

Bean は Spring コンテナ（ApplicationContext）が管理する Java オブジェクトのことです。

特徴：
- @Component、@Service、@Repository、@Controller などのアノテーション、もしくは XML 定義で登録される
- Spring が自動的に生成し、ライフサイクル（生成 → 初期化 → 破棄）を管理
- 依存関係は Spring によって自動的に注入される
- シングルトン（デフォルト）、プロトタイプ、リクエスト、セッションなどのスコープを持つ
- AOP（アスペクト指向プログラミング）による拡張が可能

Bean のライフサイクル：
1. インスタンス化
2. プロパティの設定
3. BeanNameAware、BeanFactoryAware などの Aware インターフェースの処理
4. BeanPostProcessor の前処理
5. InitializingBean の afterPropertiesSet メソッド
6. カスタム初期化メソッド
7. BeanPostProcessor の後処理
8. Bean の使用
9. DisposableBean の destroy メソッド
10. カスタム破棄メソッド

## BeanPostProcessor

BeanPostProcessor は、Bean の初期化前後に追加の処理を行うためのインターフェースです。
Bean が生成された直後、@PostConstruct や InitializingBean の処理の前後で動作します。

### 主な用途
- Bean の内容を動的に変更（ラップ、プロキシ化など）
- カスタムアノテーションの処理
- ログ出力や監視コードの埋め込み


### Bean と BeanPostProcessor の関係：
- BeanPostProcessor は Bean のライフサイクルに介入するフックを提供
- すべての Bean に対して適用される
- AOP、トランザクション管理、バリデーションなどの機能を実装するために使用される

```java
public class CustomBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) {
        // Bean の初期化前の処理
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) {
        // Bean の初期化後の処理
        return bean;
    }
}
```


## CustomBeanRegistry
Spring の標準的な @ComponentScan や XML 設定に頼らず、開発者がプログラム的に Bean を動的に登録する仕組み・実装のことを指します。

### 主な用途
通常、Spring Bean は以下の方法で登録されます：
- @Component, @Service などのアノテーションによる自動検出
- @Bean メソッドによる定義
- XML で定義

動的に Bean を追加登録したくなることがあります：
- 実行時にクラスを決定して登録したい
- プラグインのように、外部jarからロードされたクラスを Spring に組み込みたい
- メタデータやDBの内容をもとに Bean を作りたい

##  @Componentと@Controller,＠Service,@Repositoryの違い
Spring コンテナに登録するためのアノテーションで

| アノテーション       | 主な用途        | 意味的役割        | 機能的特徴                                                            |
|---------------|-------------|--------------|------------------------------------------------------------------|
| `@Component`  | 汎用的なコンポーネント | 基本の Bean 登録用 | 特別な意味を持たない                                                       |
| `@Controller` | Web層（MVC）   | リクエストの受け口    | `@RequestMapping` と連携し、レスポンスを返す                                  |
| `@Service`    | サービス層       | ビジネスロジック     | 明示的に「ロジック担当」と示す（機能的差は少）                                          |
| `@Repository` | 永続化層（DAO）   | DBアクセス担当     | Spring による例外変換（`PersistenceExceptionTranslationPostProcessor`）対象 |


# Reference

- [Inversion of Control Containers and the Dependency Injection pattern](https://martinfowler.com/articles/injection.html#InversionOfControl)
- [Spring Framework Documentation - IoC Container](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans)
