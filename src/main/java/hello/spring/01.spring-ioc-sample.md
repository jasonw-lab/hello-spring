---
title:  spring ioc sample
createTime: 2017/05/15 10:23:45
permalink: /java/spring/ioc/sample/
article: false
#sidebar: false
---

# IoCサンプル

このドキュメントでは、Spring IoC（Inversion of Control）の実装例を紹介します。サンプルコードを通じて、IoC の概念と利点を理解することが目的です。

## IoC vs 非IoC
ソース: src/main/java/hello/spring/ioc/concept

このサンプルでは、Spring IoC を使用する場合と使用しない場合の依存関係管理の違いを示しています。

### サービスインターフェースとその実装

まず、2つの基本的なサービスインターフェースとその実装があります：

**MessageService インターフェース**:
```java
public interface MessageService {
    String getMessage();
}
```

**SimpleMessageService 実装**:
```java
public class SimpleMessageService implements MessageService {
    @Override
    public String getMessage() {
        return "Hello from SimpleMessageService!";
    }
}
```

**TimeService インターフェース**:
```java
public interface TimeService {
    String getCurrentTime();
}
```

**SimpleTimeService 実装**:
```java
public class SimpleTimeService implements TimeService {
    private final DateTimeFormatter formatter = DateTimeFormatter.ofPattern("HH:mm:ss");

    @Override
    public String getCurrentTime() {
        LocalTime now = LocalTime.now();
        return formatter.format(now);
    }
}
```

### クライアントクラス

これらのサービスを使用するクライアントクラスがあります：

**MessageClient**（単一の依存関係）:
```java
public class MessageClient {
    private final MessageService messageService;

    public MessageClient(MessageService messageService) {
        this.messageService = messageService;
    }

    public String processMessage() {
        return "Client processed: " + messageService.getMessage();
    }
}
```

**ComplexClient**（複数の依存関係）:
```java
public class ComplexClient {
    private final MessageService messageService;
    private final TimeService timeService;

    public ComplexClient(MessageService messageService, TimeService timeService) {
        this.messageService = messageService;
        this.timeService = timeService;
    }

    public String createTimestampedMessage() {
        return String.format("[%s] %s", 
                timeService.getCurrentTime(), 
                messageService.getMessage());
    }
}
```

### Spring IoC アプローチ

Spring IoC を使用する場合、依存関係は Spring コンテナによって管理されます：

**設定クラス（AppConfig.java）**:
```java
@Configuration
public class AppConfig {
    @Bean
    public MessageService messageService() {
        return new SimpleMessageService();
    }

    @Bean
    public TimeService timeService() {
        return new SimpleTimeService();
    }

    @Bean
    public MessageClient messageClient(MessageService messageService) {
        return new MessageClient(messageService);
    }

    @Bean
    public ComplexClient complexClient(MessageService messageService, TimeService timeService) {
        return new ComplexClient(messageService, timeService);
    }
}
```

**Spring アプリケーション（SpringIocApplication.java）**:
```java
public static void main(String[] args) {
    // Spring アプリケーションコンテキストを作成
    try (AnnotationConfigApplicationContext context = 
            new AnnotationConfigApplicationContext(AppConfig.class)) {

        // Spring コンテキストから Bean を取得
        MessageClient simpleClient = context.getBean(MessageClient.class);
        ComplexClient complexClient = context.getBean(ComplexClient.class);

        // クライアントを使用
        String simpleResult = simpleClient.processMessage();
        String timestampedMessage = complexClient.createTimestampedMessage();

        System.out.println(simpleResult);
        System.out.println("Timestamped message: " + timestampedMessage);
    }
}
```

### 非IoC アプローチ

IoC を使用しない場合、依存関係は手動で作成および管理する必要があります：

**非IoC アプリケーション（NonIocApplication.java）**:
```java
public static void main(String[] args) {
    // サービスを手動で作成
    MessageService messageService = new SimpleMessageService();
    TimeService timeService = new SimpleTimeService();

    // クライアントを手動で作成し、依存関係を注入
    MessageClient simpleClient = new MessageClient(messageService);
    ComplexClient complexClient = new ComplexClient(messageService, timeService);

    // クライアントを使用
    String simpleResult = simpleClient.processMessage();
    String timestampedMessage = complexClient.createTimestampedMessage();

    System.out.println(simpleResult);
    System.out.println("Timestamped message: " + timestampedMessage);
}
```

### 主な違い

1. **依存関係の作成と管理**:
   - Spring IoC: コンテナが依存関係を作成し管理
   - 非IoC: 手動で依存関係を作成し管理

2. **コードの複雑さ**:
   - Spring IoC: 依存関係の管理が簡素化され、ビジネスロジックに集中できる
   - 非IoC: 依存関係が増えるにつれてコードが複雑になる

3. **テスト容易性**:
   - Spring IoC: モックや代替実装への置き換えが容易
   - 非IoC: テスト用の依存関係を手動で設定する必要がある

4. **ライフサイクル管理**:
   - Spring IoC: コンテナがオブジェクトのライフサイクルを管理
   - 非IoC: ライフサイクル管理を手動で行う必要がある

## CustomBeanRegistry
ソース: src/main/java/hello/spring/ioc/bean

このサンプルでは、Spring の BeanDefinitionRegistryPostProcessor を使用してプログラムで Bean を登録する方法を示しています。

### カスタム Bean 登録

**MessageHandler クラス**:
```java
public class MessageHandler {
    private final String handlerName;
    private final IAccountService accountService;
    private final ExecutorService executorService;

    public MessageHandler(String handlerName, IAccountService accountService, ExecutorService executorService) {
        this.handlerName = handlerName;
        this.accountService = accountService;
        this.executorService = executorService;
    }

    public void start() {
        log.info("Starting message handler...");
    }

    public void close() {
        log.info("Closing message handler...");
    }
}
```

**CustomBeanRegistry クラス**:
```java
@Configuration
public class CustomBeanRegistry implements BeanDefinitionRegistryPostProcessor {

    @Bean(name = "accountServiceImpl")
    public IAccountService accountService() {
        return new IAccountService() {
            @Override
            public void queryAccountInfo(String username) {
                log.info("Querying account info for user: {}", username);
            }
        };
    }

    @Override
    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)
            throws BeansException {
        // Bean 名を生成
        String beanName = buildBeanName("bean-name");
        // Bean 定義を作成
        BeanDefinition definition = buildBeanDefinition("bean-name");
        // Bean 定義を登録
        registry.registerBeanDefinition(beanName, definition);
    }

    private BeanDefinition buildBeanDefinition(String handlerName) {
        // Bean 定義を作成
        GenericBeanDefinition definition = newBeanDefinition();

        // コンストラクタ引数を設定
        ConstructorArgumentValues values = new ConstructorArgumentValues();
        values.addIndexedArgumentValue(0, buildBeanName(handlerName));
        values.addIndexedArgumentValue(1, new RuntimeBeanReference("accountServiceImpl"));
        values.addIndexedArgumentValue(2, buildExecutor());
        definition.setConstructorArgumentValues(values);

        // Bean クラスを設定
        definition.setBeanClassName(MessageHandler.class.getName());
        definition.setBeanClass(MessageHandler.class);

        return definition;
    }

    // Bean 定義の基本設定を作成
    public GenericBeanDefinition newBeanDefinition() {
        GenericBeanDefinition definition = new GenericBeanDefinition();
        definition.setScope(GenericBeanDefinition.SCOPE_SINGLETON);
        definition.setInitMethodName("start");
        definition.setDestroyMethodName("close");
        // その他の設定...
        return definition;
    }
}
```

**アプリケーションクラス**:
```java
public static void main(String[] args) {
    // Spring コンテキストを作成
    AbstractApplicationContext context = new AnnotationConfigApplicationContext(CustomBeanRegistry.class);

    // 登録された Bean を取得
    MessageHandler handler = (MessageHandler) context.getBean(CustomBeanRegistry.buildBeanName("bean-name"));

    // コンテキストを閉じる（Bean の破棄メソッドが呼び出される）
    context.close();
}
```

### Bean ライフサイクルの例

**ImoocBean クラス**:
```java
@Component
public class ImoocBean implements InitializingBean, BeanPostProcessor {

    // 依存性注入後に実行
    @PostConstruct
    public void init() {
        log.info("PostConstruct method called");
    }

    // プロパティ設定後に実行
    @Override
    public void afterPropertiesSet() throws Exception {
        log.info("InitializingBean.afterPropertiesSet method called");
    }

    // Bean 初期化前に実行
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        if (bean instanceof IAccountService) {
            log.info("Processing bean before initialization: {}", beanName);
        }
        return bean;
    }

    // Bean 初期化後に実行
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        if (bean instanceof IAccountService) {
            log.info("Processing bean after initialization: {}", beanName);
        }
        return bean;
    }

    // Bean 破棄時に実行
    @PreDestroy
    public void destroy() {
        log.info("PreDestroy method called");
    }
}
```

### カスタム Bean 登録の利点

1. **動的 Bean 作成**: 実行時の条件に基づいて Bean を動的に作成できる
2. **プログラムによる設定**: XML や注釈に頼らずにプログラムで Bean を設定できる
3. **複雑な依存関係**: 複雑な依存関係を持つ Bean を柔軟に設定できる
4. **外部設定の統合**: データベースや設定ファイルからの設定に基づいて Bean を作成できる

# Reference

- [Spring Framework Documentation - IoC Container](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans)
- [Spring Framework Documentation - Bean Definition](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-definition)
- [Spring Framework Documentation - Bean Post Processors](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension-bpp)
